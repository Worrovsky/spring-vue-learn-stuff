# Real world app example

## TODO

* проработать сводно разницу между data, computed, watch
* router-link, атрибут to - можно передать объект (name, param). Разобраться что это. Как быть в случае v-btn и атрибута to
* сводно записи атрибутов `:`, `@`, без

## Что интересного

Структура файлов:

- `components` - переиспользуемые компоненты
- `views` - отдельные страницы

Разное

- Имена файлов компонентов, страниц с заглавной буквы
- Использование `@` (алиас для `/src`) при импорте: например `import Home from '@/views/About.vue'`
- ленивая загрузка в роутере `component: () => import(''@/views/Home.vue)`
- Компоненты и страницы именуем с префиксом, чтобы отличать собственные от заимствованных из сторонних библиотек. Например по первым символам собственного приложения и библиотек или по префиксу `App` для собственных

Страницы и роутер:

    {
      path: '/register',
      name: 'register',
      component: () => import('@/views/Register.vue'),
    },

- обязательно используем `name`
  - линки только через `name`, не через `path`
- имя со строчной

## Vuetify

### 
Основа

    <v-app>
      <v-main>
        <v-container>

        </v-container>
      </v-main>
    <v-app>

Внутри контейнера обычно строки и колонки

    <v-container>
      <v-row>
        <v-col>
        </v-col>
      </v-row>
    </v-container>

### Особенности v-progress-linear

Не отображается, если в компоненте ничего нет кроме него самого по условию.

Например не отображается:

    <template>
      <div>
        <v-progress-linear v-if="isLoading" rounded
      height="6" />
        <h1 v-if="!isLoading">Hello</h1>
      </div>
    </template>

А так отображается:
  
    <template>
      <div>
        <v-progress-linear v-if="isLoading" rounded
            height="6" />
        <h1>Hello</h1>
      </div>
    </template>

Вообще лучше **помещать в контейнер**

    <v-container>
      <v-row>
        <app-loading v-if="isLoading" />
      </v-row>
    </v-container>


## Vuex

### Основы

Глобально хранит и изменяет состояние всего приложения

Создаем переменные в области `state`

Определяем мутации для них

Используем в компонентах,создавая computed-свойства (удобнее так)

### Модули

Для разделения переменных по областям использовать модули

Структура папок:

    src
      `--store
          |--modules
          |   `--auth.js
          `--index.js

Содержимое модуля - это состояние, мутации и т.п. как для общего хранилища и их импорт

    //файл scr/store/modules/auth.js
    const state = {
      a: 1
    }
    const mutations = {
      // ...
    }
    export default {
      state,
      mutation
    }

Далее модуль импортируем в основной объект хранилища

    //файл src/store/index.js
    ...
    import auth from '@/store/index.js'
    ...
    export default new Vuex.Store({
      ...
      modules: {
        auth
      }

Теперь можно использовать в компонентах

Обращение к переменной через префикс модуля `this.$store.state.auth.isSubmitting`

Вызов мутации обычным способом `this.$store.commit('registerStart')`

### Actions

По сути те же мутации, но внутри обычно выполняются асинхронные операции (api-запросы, работа с БД)

    ...
    actions: {
      someAction(context) {
        // context - это само хранилище (this.$store),поэтому можно напр.
        context.commit('registerStart')
      }
    }

Вызов через метод `dispatch` `this.$store.dispatch('someAction')`

## Схема взаимодействия с API с помощью axios

- Создаем прослойку для axios (для конкретной настройки: например base url)
- На каждую сущность создаем свой js файл с запросами. В этих запросах используется объект axios из прослойки

Структура файлов

    src
        |...
        `api
            |--axios.js
            `--auth.js

- Запрос - просто вызов нужного метода у `axios`, например `axios.post('/users', credentials)`
- Этот запрос используем в action хранилища (модули используем) через **Promise**

Например:

    const actions = {
        register(context, creds) {
            return new Promise(() = > {
                authApi.register()
                .then(...)
                .catch(...)
            })
        }
    }

- Для отслеживвания состояния запроса (например для изменения доступности кнопки на период запроса) создаем мутации по схеме `xxxStart`, `xxxSuccess`, `xxxFailure` и используем их на этапах обработки запроса. См. пример с `isSubmitting` в файле `@/store/module/auth.js`

- Передача результата запроса: стандартными средствами **Promise** через функцию `resolve` 

Пример

    //файл модуля store, метод actions
    ...
      return new Promise((resolve) => {
        someApi.someApiMethod()
          .then((response) => {
            ...
            resolve(response.data.<что-то из данных>)
            })
      }

      //файл компонента
      ...
        this.$store.dispatch(...)
          .then((<данные, переданные через resolve>) => {...})


## Конвенция именования мутаций и действий Vuex

Проблемы:

* Мутации и действия имеют глобальную область видимости, поэтому нельзя одинаковое наименование использовать в разных модулях
* Вызов мутаций и действий выполняется по строковым именам: возможны ошибки, опечатки

Предлагается такая техника (что-то аналогичное в Redux):

* В модуле, где определены мутации/действия, создаем объект `mutationTypes` с перечислением зарегистрированных мутаций и их псевдонимов, и экспортируем его. Псевдонимы задаем с префиксами

Например:

    //файл модуля vuex (напр. /store/modules/auth.js)
    export const mutationTypes = {
      registerStart: '[auth] registerStart',
      ...
    }

* Добавляем в само определение мутаций использование объекта с псевдонимами

Вот пример. Здесь `[]` используются для вычисления выражения (?? не очень понятно)

    //файл модуля vuex (напр. /store/modules/auth.js)
    const mutations = {
      [mutationTypes.registerStart](state) {
        state.isSubmitting = false
      }
    }

* И теперь вызов мутации/действия тоже через пcевдонимы

Например в том же модуле

    //файл модуля vuex (напр. /store/modules/auth.js)
    ...
    context.commit(mutationTypes.registerStart)

Или в компоненте (внимание на импорт через {})

    //файл компонента
    import {actionTypes} from '@/store/modules/auth'
    ...
      onSubmit() {
        this.$store.dispatch(actionTypes.register)
      }

## Использование mapState

Пример. Обращать внимание на spread-оператор (...) 

    import {mapState} from 'vuex'
    ...
      computed: {
        ...mapState({
          isSubmitting: state => state.auth.isSubmitting,
          ... 
        })
      }

* немного сокращает запись
* группирует вычисляемые свойства, связанные с хранилищем, в одном месте, что упрощает сопровождение

## Геттеры в Vuex

Когда нужно получить значения на основе свойств хранилища или просто получить эти свойства. Аналог `computed`.

    // файл модуля хранилища (напр. @/store/modules/auth)
    const getters = {
      currentUser: state => {
        return state.currentUser // здесь нет префиксов, видим то, что есть в хранилище "локальном"
      }
    }
    ... 
    export default {
      ...,
      getters
    }

Можно применять ту же технику с `getterTypes` как для мутаций и действий

Вызывать можно через `$store.getters.currentUser` или через хелпер `mapGetters`(объект, ключ - имя свойства в компоненте, значение - имя геттера, заданное в хранилище)

    // файл компонента, где нужно вызвать геттер
    import {mapGetters} from 'vuex'
    iimport {getterTypes} from '@/store/modules/auth'
    ...
    computed: {
      ...mapGetters({
        currentUser: getterTypes.currentUser,
      })
    }
  


## Авторизация в приложении при обновлении страниц

* Пользователь ввел логин/пароль на странице `signin`, в `local storage` сохранен токен
* Как теперь при обновлении страницы, переходе на `/home` не потерять состояние `авторизован`

Решение:

* backend должен по `get` запросу c токеном в заголовке `Authorization` на адрес `/user` (например) возвращать данные пользователя, если токен правильный
* этот запрос вставляем туда, где будет вызываться часто. Например `mounted()` корневого компонента приложения
* Все это организуем через хранилище (действие `getCurrentUser` и состояния)
* чтобы передавать токен в запросе, настраиваем interceptors в axios (см. `@/api/axios.js`). Да теперь токен во всех запросах будет, ну и пусть

## Пагинация

Создаем отдельный компонент. В него передаем параметрами (описано со стороны компонента, который использует пагинацию (например `feed.js`)):

* `total` - общее количество страниц (запрос к бекенду возвращает массив объектов и общее количество)
  - `:total="feed.articlesCount"`
* `limit` - количество элементов на страницу
  - можно вынести в отдельный модуль как константу
* `baseUrl` - URL для обращения к API (общий компонент для разных страниц, API меняется). Компонент пагинации будет перенаправлять на этот URL при изменении страницы
  - можно через вычисляемое свойство `this.$route.path`
* `currentPage` - для выделения элемента пагинации, соответствующей текущей странице
  - через вычисляемое свойство `Number(this.$route.query.page || '1')`


Сам компонент `@/components/Pagination.vue`: 

* Вычисляет общее количество страниц `Math.ceil(this.total / this.limit)`
* Содержит переменную (в `data()`), которая хранит текущую страницу
* При изменении страницы (`@input=...`) выполняем переход по адресу `baseUrl` номером страницы в параметрах `this.$router.push({ path: this.url, query: { page: page } })`

Как организовать изменение данных в компоненте при смене страницы:

* Факт изменения query-параметра не является для Vue поводом для перерисовки (т. е. `mount()` не вызывается)
* Создаем `watch` для наблюдения за `currentPage`, которое в свою очередь основано на query-параметре `page`
* Теперь нужно сформировать URL с query-параметром. Делать это через конкатенацию строк не стоит (неподдерживаемо, вероятны ошибки и т.п.), подключаем библиотеку `query-string`
* В query параметры добавляем offset и limit и выполняем action на запрос

## Vuetify и router/ссылки

Стандартно во Vue можно обертывать `router-link` во что-то, например внутри элемента списка: 

    <li>
      <router-link :to="{name: 'somePathName'}">To ...</router-link>
    </li>


В Vuetify и разных элементов (кнопки, элементы списка) есть свойство **to**, можно сразу указывать:

    <v-btn :to="{ name: 'home' }">Home</v-btn>

Или можно внутрь `router-link` помещать элементы, например картинки

Убрать подчеркивание текста с ссылок: добавление класса `text-decoration-none`:

    <router-link class="text-body-1 text-decoration-none green--text text--darken-3">...

Чтобы ссылка подсвечивалась только при полном совпадении с адресом, используем атрибут **exact**. Например путь в адресной строке `/home`, в свойстве `to` у ссылки `/`. Тогда без этого атрибута ссылка будет подсвечена (из-за частичного совпадения)

    <v-btn x-small rounded :to="{ name: 'home' }" exact>Global Feed</v-btn>


