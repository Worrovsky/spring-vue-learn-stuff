# Real world app example

<!-- MarkdownTOC levels="2,3" autolink="true" -->

- [0. Начало](#0-%D0%9D%D0%B0%D1%87%D0%B0%D0%BB%D0%BE)
- [1. Организация проекта](#1-%D0%9E%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0)
- [2. Заметки по Vue](#2-%D0%97%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8-%D0%BF%D0%BE-vue)
  - [2.1 v-on, v-bind и их замены \(сводно\)](#21-v-on-v-bind-%D0%B8-%D0%B8%D1%85-%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D1%8B-%D1%81%D0%B2%D0%BE%D0%B4%D0%BD%D0%BE)
  - [2.2 Сравнение data, computed, watch, method](#22-%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-data-computed-watch-method)
- [3. Vuetify](#3-vuetify)
  - [3.1 Основа](#31-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%B0)
  - [3.2 Особенности v-progress-linear](#32-%D0%9E%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-v-progress-linear)
  - [3.3 Vuetify и router/ссылки](#33-vuetify-%D0%B8-router%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)
- [4. Vuex](#4-vuex)
  - [4.1 Основы](#41-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B)
  - [4.2 Модули](#42-%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B8)
  - [4.3 Actions](#43-actions)
  - [4.4 Конвенция именования мутаций и действий Vuex](#44-%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D0%BD%D1%86%D0%B8%D1%8F-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BC%D1%83%D1%82%D0%B0%D1%86%D0%B8%D0%B9-%D0%B8-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B9-vuex)
  - [4.5 Использование mapState](#45-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-mapstate)
  - [4.6 Геттеры в Vuex](#46-%D0%93%D0%B5%D1%82%D1%82%D0%B5%D1%80%D1%8B-%D0%B2-vuex)
- [5. Router](#5-router)
  - [5.1 Добавление Router в проект](#51-%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-router-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82)
  - [5.2 Использование путей](#52-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9)
  - [5.3 Динамические пути и $route](#53-%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B8-%D0%B8-%24route)
  - [5.4 Программная навигация через $router](#54-%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D0%B2%D0%B8%D0%B3%D0%B0%D1%86%D0%B8%D1%8F-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%24router)
- [6. Разное](#6-%D0%A0%D0%B0%D0%B7%D0%BD%D0%BE%D0%B5)
  - [6.1 Схема взаимодействия с API с помощью axios](#61-%D0%A1%D1%85%D0%B5%D0%BC%D0%B0-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D1%81-api-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-axios)
  - [6.2 Авторизация в приложении при обновлении страниц](#62-%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86)
  - [6.3 Пагинация](#63-%D0%9F%D0%B0%D0%B3%D0%B8%D0%BD%D0%B0%D1%86%D0%B8%D1%8F)
  - [6.4 Optimistic Updates](#64-optimistic-updates)

<!-- /MarkdownTOC -->


## 0. Начало

Запуск `npm run serve`

В качестве бекенда - `https://conduit.productionready.io`
см. [RealWorld](https://github.com/gothinkster/realworld)

## 1. Организация проекта

Структура файлов:

* `components` - переиспользуемые компоненты
* `views` - отдельные страницы

Разное:

* Имена файлов компонентов, страниц с заглавной буквы
* Использование `@` (алиас для `/src`) при импорте: например `import Home from '@/views/About.vue'`
* ленивая загрузка в роутере `component: () => import(''@/views/Home.vue)`
* Компоненты и страницы именуем с префиксом, чтобы отличать собственные от заимствованных из сторонних библиотек. Например по первым символам собственного приложения и библиотек или по префиксу `App` для собственных

## 2. Заметки по Vue

### 2.1 v-on, v-bind и их замены (сводно)

**v-on** - назначение обработчика на событие.
краткая запись: **@**

    <v-btn @click="onClick">Click</v-btn>

**v-bind** - установка атрибута у элемента.
краткая запись: **:**

    <v-btn :class="someComputedProperty"/> 

можно объектами передавать

    // flag - computed- или data-свойство
    <v-btn :class="{
        "bg-light": flag,
        "text-light": !flag};
      }"/>



### 2.2 Сравнение data, computed, watch, method

**data** - просто свойства, не зависят ни от чего. 
В скриптах обращение через `this`, в шаблонах - без.
Не могут менять другие данные.

**computed** - зависят от других данных. Вычисляются один раз при загрузке страницы и кешируются. Но реактивны: вычисляются заново при изменении составляющих.
В скриптах обращение через `this`, в шаблонах - без.
Могут менять другие данные, но не стоит (без сайд-эффектов).
Не стоит использовать для асинхронных операций.

**method** - функции, в отличие от computed не кешируются, вычисляются каждый раз при использовании.
В скриптах обращение через `this`, в шаблонах - без (но может не стоит в шаблонах).
Могут менять другие данные.

**watch** - функции, реагирующие на изменении data- или computed-свойства.
Могут менять другие данные.


## 3. Vuetify

### 3.1 Основа

Один раз на все приложение используем **v-app** (см. `@/App.vue`)

    <v-app>
      <v-main>
        ...
      </v-main>
    <v-app>

В компонентах, страницах можно использовать контейнер, внутри контейнера обычно строки и колонки

    <v-container>
      <v-row>
        <v-col>
        </v-col>
      </v-row>
    </v-container>

### 3.2 Особенности v-progress-linear

Не отображается, если в компоненте ничего нет кроме него самого по условию.

Например не отображается:

    <template>
      <div>
        <v-progress-linear v-if="isLoading" rounded
      height="6" />
        <h1 v-if="!isLoading">Hello</h1>
      </div>
    </template>

А так отображается:
  
    <template>
      <div>
        <v-progress-linear v-if="isLoading" rounded
            height="6" />
        <h1>Hello</h1>
      </div>
    </template>

Вообще лучше **помещать в контейнер**

    <v-container>
      <v-row>
        <app-loading v-if="isLoading" />
      </v-row>
    </v-container>




### 3.3 Vuetify и router/ссылки

Стандартно во Vue можно обертывать `router-link` во что-то, например внутри элемента списка: 

    <li>
      <router-link :to="{name: 'somePathName'}">To ...</router-link>
    </li>

В Vuetify и разных элементов (кнопки, элементы списка) есть свойство **to**, можно сразу указывать:

    <v-btn :to="{ name: 'home' }">Home</v-btn>

Или можно внутрь `router-link` помещать элементы, например картинки

**Убрать подчеркивание текста с ссылок**: добавление класса `text-decoration-none`:

    <router-link class="text-body-1 text-decoration-none green--text text--darken-3">...

Чтобы **ссылка подсвечивалась только при полном совпадении с адресом**, используем атрибут **exact**. Например путь в адресной строке `/home`, в свойстве `to` у ссылки `/`. Тогда без этого атрибута ссылка будет подсвечена (из-за частичного совпадения)

    <v-btn x-small rounded :to="{ name: 'home' }" exact>Global Feed</v-btn>

## 4. Vuex

### 4.1 Основы

Глобально хранит и изменяет состояние всего приложения

Создаем переменные в области `state`

Определяем мутации для них

Используем в компонентах,создавая computed-свойства (удобнее так)

### 4.2 Модули

Для разделения переменных по областям использовать модули

Структура папок:

    src
      `--store
          |--modules
          |   `--auth.js
          `--index.js

Содержимое модуля - это состояние, мутации и т.п. как для общего хранилища и их импорт

    //файл scr/store/modules/auth.js
    const state = {
      a: 1
    }
    const mutations = {
      // ...
    }
    export default {
      state,
      mutation
    }

Далее модуль импортируем в основной объект хранилища

    //файл src/store/index.js
    ...
    import auth from '@/store/index.js'
    ...
    export default new Vuex.Store({
      ...
      modules: {
        auth
      }

Теперь можно использовать в компонентах

Обращение к переменной через префикс модуля `this.$store.state.auth.isSubmitting`

Вызов мутации обычным способом `this.$store.commit('registerStart')`

### 4.3 Actions

По сути те же мутации, но внутри обычно выполняются асинхронные операции (api-запросы, работа с БД)

    ...
    actions: {
      someAction(context) {
        // context - это само хранилище (this.$store),поэтому можно напр.
        context.commit('registerStart')
      }
    }

Вызов через метод `dispatch` `this.$store.dispatch('someAction')`

### 4.4 Конвенция именования мутаций и действий Vuex

Проблемы:

* Мутации и действия имеют глобальную область видимости, поэтому нельзя одинаковое наименование использовать в разных модулях
* Вызов мутаций и действий выполняется по строковым именам: возможны ошибки, опечатки

Предлагается такая техника (что-то аналогичное в Redux):

* В модуле, где определены мутации/действия, создаем объект `mutationTypes` с перечислением зарегистрированных мутаций и их псевдонимов, и экспортируем его. Псевдонимы задаем с префиксами

Например:

    //файл модуля vuex (напр. /store/modules/auth.js)
    export const mutationTypes = {
      registerStart: '[auth] registerStart',
      ...
    }

* Добавляем в само определение мутаций использование объекта с псевдонимами

Вот пример. Здесь `[]` используются для вычисления выражения (?? не очень понятно)

    //файл модуля vuex (напр. /store/modules/auth.js)
    const mutations = {
      [mutationTypes.registerStart](state) {
        state.isSubmitting = false
      }
    }

* И теперь вызов мутации/действия тоже через пcевдонимы

Например в том же модуле

    //файл модуля vuex (напр. /store/modules/auth.js)
    ...
    context.commit(mutationTypes.registerStart)

Или в компоненте (внимание на импорт через {})

    //файл компонента
    import {actionTypes} from '@/store/modules/auth'
    ...
      onSubmit() {
        this.$store.dispatch(actionTypes.register)
      }


### 4.5 Использование mapState

Пример. Обращать внимание на spread-оператор (...) 

    import {mapState} from 'vuex'
    ...
      computed: {
        ...mapState({
          isSubmitting: state => state.auth.isSubmitting,
          ... 
        })
      }

* немного сокращает запись
* группирует вычисляемые свойства, связанные с хранилищем, в одном месте, что упрощает сопровождение

### 4.6 Геттеры в Vuex

Когда нужно получить значения на основе свойств хранилища или просто получить эти свойства. Аналог `computed`.

    // файл модуля хранилища (напр. @/store/modules/auth)
    const getters = {
      currentUser: state => {
        return state.currentUser // здесь нет префиксов, видим то, что есть в хранилище "локальном"
      }
    }
    ... 
    export default {
      ...,
      getters
    }

Можно применять ту же технику с `getterTypes` как для мутаций и действий

Вызывать можно через `$store.getters.currentUser` или через хелпер `mapGetters`(объект, ключ - имя свойства в компоненте, значение - имя геттера, заданное в хранилище)

    // файл компонента, где нужно вызвать геттер
    import {mapGetters} from 'vuex'
    iimport {getterTypes} from '@/store/modules/auth'
    ...
    computed: {
      ...mapGetters({
        currentUser: getterTypes.currentUser,
      })
    }
  


## 5. Router

### 5.1 Добавление Router в проект

* `npm install vue-router`
* создать объект **VueRouter** (см. `@/router/index.js`)
  - прописать пути, связать с компонентами
  - экспортировать
* добавить объект **VueRouter** в корневой объект **Vue** (см. `@/main.js`)
* добавить место для включения компонент **<router-view>** (см. `@/App.vue`)

### 5.2 Использование путей

    // файл @/router/index.js
    const routes = [
      {
        path: '/register',
        name: 'register',
        component: () => import('@/views/Register.vue'),
      },
    ]

* обязательно используем `name`
* линки только через `name`, не через `path`
* имя пути со строчной

### 5.3 Динамические пути и $route

Пути можно задавать с динамическими частями. Разделитель - `:`. Например `{path: '/user/:id', component: User}`

Этому пути соответствуют например `/user/foo` и `/user/bar`

Теперь через объект **$route** есть доступ к этим параметрам: `this.$route.params.id`

Также у **$route** есть доступ к другим частям пути: `path`, `hash`, `query`

Если путь динамический, вызов его например так:

    <router-link :to="{
        name: 'userProfile',
        params: { slug: article.author.username },
      }">

### 5.4 Программная навигация через $router

    this.$router.push(
      { name: 'article', params: { slug: article.slug } }
    )

Здесь внимание на то, что `params` будет учитываться, только если путь задан через `name`, не `path`

**Но** для `query` можно и с `path`:

    this.$router.push(
      { path: 'register', query: { plan: 'private' } }
    )


## 6. Разное 
### 6.1 Схема взаимодействия с API с помощью axios

- Создаем прослойку для axios (для конкретной настройки: например base url)
- На каждую сущность создаем свой js файл с запросами. В этих запросах используется объект axios из прослойки

Структура файлов

    src
        |...
        `api
            |--axios.js
            `--auth.js

- Запрос - просто вызов нужного метода у `axios`, например `axios.post('/users', credentials)`
- Этот запрос используем в action хранилища (модули используем) через **Promise**

Например:

    const actions = {
        register(context, creds) {
            return new Promise(() = > {
                authApi.register()
                .then(...)
                .catch(...)
            })
        }
    }

- Для отслеживвания состояния запроса (например для изменения доступности кнопки на период запроса) создаем мутации по схеме `xxxStart`, `xxxSuccess`, `xxxFailure` и используем их на этапах обработки запроса. См. пример с `isSubmitting` в файле `@/store/module/auth.js`

- Передача результата запроса: стандартными средствами **Promise** через функцию `resolve` 

Пример

    //файл модуля store, метод actions
    ...
      return new Promise((resolve) => {
        someApi.someApiMethod()
          .then((response) => {
            ...
            resolve(response.data.<что-то из данных>)
            })
      }

      //файл компонента
      ...
        this.$store.dispatch(...)
          .then((<данные, переданные через resolve>) => {...})


### 6.2 Авторизация в приложении при обновлении страниц

* Пользователь ввел логин/пароль на странице `signin`, в `local storage` сохранен токен
* Как теперь при обновлении страницы, переходе на `/home` не потерять состояние `авторизован`

Решение:

* backend должен по `get` запросу c токеном в заголовке `Authorization` на адрес `/user` (например) возвращать данные пользователя, если токен правильный
* этот запрос вставляем туда, где будет вызываться часто. Например `mounted()` корневого компонента приложения
* Все это организуем через хранилище (действие `getCurrentUser` и состояния)
* чтобы передавать токен в запросе, настраиваем interceptors в axios (см. `@/api/axios.js`). Да теперь токен во всех запросах будет, ну и пусть

### 6.3 Пагинация

Создаем отдельный компонент. В него передаем параметрами (описано со стороны компонента, который использует пагинацию (например `feed.js`)):

* `total` - общее количество страниц (запрос к бекенду возвращает массив объектов и общее количество)
  - `:total="feed.articlesCount"`
* `limit` - количество элементов на страницу
  - можно вынести в отдельный модуль как константу
* `baseUrl` - URL для обращения к API (общий компонент для разных страниц, API меняется). Компонент пагинации будет перенаправлять на этот URL при изменении страницы
  - можно через вычисляемое свойство `this.$route.path`
* `currentPage` - для выделения элемента пагинации, соответствующей текущей странице
  - через вычисляемое свойство `Number(this.$route.query.page || '1')`


Сам компонент `@/components/Pagination.vue`: 

* Вычисляет общее количество страниц `Math.ceil(this.total / this.limit)`
* Содержит переменную (в `data()`), которая хранит текущую страницу
* При изменении страницы (`@input=...`) выполняем переход по адресу `baseUrl` номером страницы в параметрах `this.$router.push({ path: this.url, query: { page: page } })`

Как организовать изменение данных в компоненте при смене страницы:

* Факт изменения query-параметра не является для Vue поводом для перерисовки (т. е. `mount()` не вызывается)
* Создаем `watch` для наблюдения за `currentPage`, которое в свою очередь основано на query-параметре `page`
* Теперь нужно сформировать URL с query-параметром. Делать это через конкатенацию строк не стоит (неподдерживаемо, вероятны ошибки и т.п.), подключаем библиотеку `query-string`
* В query параметры добавляем offset и limit и выполняем action на запрос


### 6.4 Optimistic Updates

Это решение, когда не ждем результата с бекенда (блокируя интерфейс или часть его), а сразу изменяем на клиенте состояние. Полагаем, что на сервере все произойдет без ошибок. 

Подходит для "неважных" операций. Пример см. `@/components/AddToFavorites.vue`

[За-Против (habr)](https://habr.com/ru/post/319392/)




